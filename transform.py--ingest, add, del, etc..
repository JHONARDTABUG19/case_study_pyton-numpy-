import csv
import os

# Configuration - same as main.py
FILENAME = "ano.csv"
HEADER = [
    "student_id",
    "last_name",
    "first_name",
    "section",
    "quiz1",
    "quiz2",
    "quiz3",
    "quiz4",
    "quiz5",
    "midterm",
    "final",
    "attendance_percent"
]

def clean_ingest(filename=FILENAME):
    """
    Reads a CSV file, validates each row, and separates good rows from bad rows.
    Blanks or invalid numeric fields (quiz1–attendance) are converted to None.
    Returns: tuple (valid_rows, bad_rows)
    """
    # Check if file exists
    if not os.path.exists(filename):
        print(" File not found.")
        return [], []

    # Lists to store valid and invalid rows
    valid_rows = []
    bad_rows = []

    # Open and read the CSV file
    with open(filename, "r", newline="", encoding="utf-8") as f:
        reader = csv.reader(f)
        rows = list(reader)

    # If file is empty, return empty lists
    if not rows:
        return [], []

   
    header = rows[0]
    data_rows = rows[1:]

    # Process each data row
    for row in data_rows:
        try:
            # Add empty strings if row has missing columns
            while len(row) < len(header):
                row.append("")

            # Validate student_id (first column, index 0)
            if not row[0].strip():
                raise ValueError("Missing student_id")

            # Validate numeric fields (columns 4-11: quizzes, midterm, final, attendance)
            for i in range(4, 12):
                # Get the value and clean it
                val = row[i].strip() if isinstance(row[i], str) else row[i]
                
                #  If blank or "none", set to None (no score)
                if val == "" or str(val).lower() == "none":
                    row[i] = None
                else:
                    try:
                        # Convert to number
                        num_val = float(val)
                        #  Check if score is between 0 and 100
                        if not (0 <= num_val <= 100):
                            raise ValueError(f"{header[i]} out of range")
                        row[i] = num_val
                    except ValueError:
                        #  If invalid, set to None instead of throwing error
                        row[i] = None

            # Validate names/section (columns 1-3: last_name, first_name, section)
            for i in range(1, 4):
                # If empty, set to "none"
                if not row[i].strip():
                    row[i] = "none"

            # Row is valid, add to valid list
            valid_rows.append(row)

        except Exception as e:
            # Row has error, add error message and add to bad list
            row.append(str(e))
            bad_rows.append(row)

    # Print summary
    print(f"\n Valid rows: {len(valid_rows)}")
    print(f" Bad rows: {len(bad_rows)}")
    if bad_rows:
        print("\nBad rows:")
        for r in bad_rows:
            print(r)

    return valid_rows, bad_rows


def save_to_csv(data, filename=FILENAME):
    """Append data to CSV, create header if file doesn't exist"""
    # Check if file already exists
    file_exists = os.path.exists(filename)
    
    # Open file in append mode (adds to end of file)
    with open(filename, "a", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        # If new file, write header first
        if not file_exists:
            writer.writerow(HEADER)
        # Write all data rows
        writer.writerows(data)
    print(f" Data saved to {filename}")


def save_cleaned_csv(valid_rows, filename=FILENAME):
    """Overwrite CSV with only valid rows"""
    # Open file in write mode (replaces all content)
    with open(filename, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        # Write header
        writer.writerow(HEADER)
        # Write only the valid rows
        writer.writerows(valid_rows)
    print(f" Cleaned data saved to {filename}")


# ----------------------
# CRUD Operations
# ----------------------
def add_data():
    """
    Adds one or more students interactively with name validation (no numbers).
    """
    new_rows = []
    # Ask how many students to add
    n = int(input("How many students to add? "))

    # Loop for each student
    for i in range(n):
        print(f"\n--- Student #{i+1} ---")
        print(f"--- student_id is required ---\n")
        student = []

        # Loop through each field in HEADER
        for idx, h in enumerate(HEADER):
            while True:  # Keep asking until valid input
                val = input(f"Enter {h} (leave blank for 'none'): ").strip()

                # Validate student_id (index 0) - cannot be empty
                if idx == 0:
                    if not val:
                        print(" student_id cannot be empty. Try again.")
                        continue
                    student.append(val)
                    break

                 # Validate names (index 1, 2) - no numbers allowed
                elif idx in [1, 2]:  # last_name, first_name
                    if val == "":
                        val = "none"
                    # Check if any character is a digit
                    elif any(char.isdigit() for char in val):
                        print(" Names cannot contain numbers. Try again.")
                        continue
                    student.append(val)
                    break

                # Section (index 3) – allow letters and numbers
                elif idx == 3:
                    if val == "":
                        val = "none"
                    student.append(val)
                    break

                # Validate numeric fields (index 4-11: quizzes, midterm, final, attendance)
                elif idx in range(4, 12):
                    # If blank or "none", store as "none"
                    if val == "" or val.lower() == "none":
                        student.append("none")
                        break
                    try:
                        # Convert to number
                        num_val = float(val)
                        # Check if between 0 and 100
                        if not (0 <= num_val <= 100):
                            print(" Score must be between 0 and 100. Try again.")
                            continue
                        student.append(num_val)
                        break
                    except ValueError:
                        print(" Invalid number. Enter 0–100 or leave blank for 'none'.")
                        continue

        # Add completed student record to list
        new_rows.append(student)

    # Save all new students to CSV
    save_to_csv(new_rows)


def delete_data(filename=FILENAME):
    # Check if file exists
    if not os.path.exists(filename):
        print(" File not found.")
        return

    # Ask for student ID to delete
    student_id = input("Enter student_id to delete: ")
    
    # Read all valid rows
    valid_rows, _ = clean_ingest(filename)
    
    # Keep only rows where student_id doesn't match (filter out the one to delete)
    updated_rows = [row for row in valid_rows if row[0] != student_id]

    # If no rows were removed, student wasn't found
    if len(updated_rows) == len(valid_rows):
        print(" No student found with that ID.")
        return

    # Save the updated list (without the deleted student)
    save_cleaned_csv(updated_rows)
    print(f" Deleted student_id {student_id} successfully.")


def select_column(filename=FILENAME):
    """Display all values from a specific column"""
    # Read all valid rows
    valid_rows, _ = clean_ingest(filename)
    if not valid_rows:
        print(" No valid data.")
        return

    # Show available columns
    print("\nAvailable columns:")
    for i, col in enumerate(HEADER):
        print(f"{i+1}. {col}")

    # Ask user which column to view
    col_name = input("Enter column name to view: ").strip()
    if col_name not in HEADER:
        print(" Invalid column name.")
        return

    # Find the column index
    index = HEADER.index(col_name)
    
    # Print all values in that column
    print(f"\n Values under '{col_name}':")
    for row in valid_rows:
        print(row[index])


def select_row(filename=FILENAME):
    """Display all information for a specific student"""
    # Read all valid rows
    valid_rows, _ = clean_ingest(filename)
    if not valid_rows:
        print(" No valid data.")
        return

    # Ask for student ID
    student_id = input("Enter student_id to view: ")
    
    # Search for the student
    for row in valid_rows:
        if row[0] == student_id:  # Check if student_id matches
            # Display all fields for this student
            print("\n Student Information:")
            for h, v in zip(HEADER, row):  # zip pairs each header with its value
                print(f"{h}: {v}")
            return

    # If loop completes without finding student
    print(" No student found with that ID.")


# ----------------------
# SORTING Feature
# ----------------------
def sort_data(filename=FILENAME):
    """
    Sort student data by any column in ascending or descending order.
    Saves the sorted data back to the CSV file.
    """
    # Read all valid rows
    valid_rows, _ = clean_ingest(filename)
    if not valid_rows:
        print(" No valid data to sort.")
        return

    # Show available columns to sort by
    print("\n Available columns to sort by:")
    for i, col in enumerate(HEADER):
        print(f"{i+1}. {col}")

    # Ask user which column to sort by
    col_name = input("\nEnter column name to sort by: ").strip()
    if col_name not in HEADER:
        print(" Invalid column name.")
        return

    # Get the column index (position in the row)
    col_index = HEADER.index(col_name)

    # Ask for sort order (ascending or descending)
    print("\nSort order:")
    print("1. Ascending (A→Z, 0→100)")
    print("2. Descending (Z→A, 100→0)")
    order = input("Enter choice (1 or 2): ").strip()

    # Set reverse flag (True = descending, False = ascending)
    reverse = True if order == "2" else False

    # Check if column contains numbers (indices 4-11) or text (0-3)
    is_numeric = col_index in range(4, 12)

    # Define how to sort each row (the "key" function)
    def sort_key(row):
        value = row[col_index]
        
        if is_numeric:
            # For numeric columns, handle None values
            # None becomes -infinity (appears first) when ascending
            # None becomes +infinity (appears last) when descending
            if value is None:
                return float('-inf') if not reverse else float('inf')
            return float(value)
        else:
            # For text columns, convert to lowercase for consistent sorting
            if value is None or str(value).lower() == "none":
                return ""
            return str(value).lower()

    try:
        # Sort the rows using the sort_key function
        sorted_rows = sorted(valid_rows, key=sort_key, reverse=reverse)
        
        # Save sorted data back to CSV
        save_cleaned_csv(sorted_rows, filename)
        
        print(f"\n Data sorted by '{col_name}' ({'descending' if reverse else 'ascending'})")
        
        # Display first 10 rows as a preview
        print(f"\n Preview (first 10 rows):")
        print("-" * 100)
        print(f"{'ID':<12} {'Last Name':<15} {'First Name':<15} {'Section':<10} {col_name:<15}")
        print("-" * 100)
        
        # Show first 10 rows
        for row in sorted_rows[:10]:
            # Display "N/A" if value is None
            display_val = row[col_index] if row[col_index] is not None else "N/A"
            # <12 means left-align in 12 character width
            print(f"{row[0]:<12} {row[1]:<15} {row[2]:<15} {row[3]:<10} {str(display_val):<15}")
        
        # Show how many more rows there are
        if len(sorted_rows) > 10:
            print(f"\n... and {len(sorted_rows) - 10} more rows")
        
    except Exception as e:
        print(f" Error during sorting: {e}")
